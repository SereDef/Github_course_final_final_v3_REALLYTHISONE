# Welcome

Welcome to our first **`Git` & `Github`** course! I am happy that you are here, this is sort of the first for me, I hope you'll enjoy.

The goal of today is to a) get you excited about using these tools in your work but also b) walk you through the necessary setup and creating your first few Git projects. 

So we will see together how to Install and congifure `Git` and get it working smoothly with `GitHub` in the ***shell*** & in ***RStudio***. 
What are some daily tasks or **workflows** for your most common tasks
And find out some (very cool) ways to integrate `Git` and `GitHub` into your daily work. the perks you don't often hear about. 

## More disclaimers 

About me:
- I will try to anwer your questions 
- I am also a heavier Linux/Mac OS user, so I do include slides for Windows users but I may not be the best person to ask specific questions about

About you:
The target audience for this site is someone who analyzes data, probably with R, though some of the content may be useful to analysts using other languages.
You should have a good grasp of files and directories and be generally knowledgeable about where things live on your computer.
- Why R? because I use it... but also there sort of a special synergy between R/RStudio and GitHub, which provides a powerful way to get started
Although we will show alternatives for most Git operations, we will inevitably spend some time in the shell and we assume some prior experience.

About this worshop:
The goal is to help the Git-curious generate the activation energy needed to get started.
Here, we will highlight the most rewarding usage patterns for **research / teaching**.

Becasue most Git/GitHub users are software developers (differences in the user’s context and objective), some resources are not tailored for us

We aim to teach novices about Git on a strict “need to know” basis. Git was built to manage development of the Linux kernel, which is probably very different from what you do. Most people need a small subset of Git’s functionality and that will be our focus. 

## Roadtrip checklist 
Courses or research/lab groups, where you need some coordination across a set of repos and users

## Agenda
Could the gains ever possibly justify the inevitable pain? 
I say yes, with the zeal of the converted.

Configure a personal access token or set up SSH keys.
Prove local Git can talk to GitHub.

# Part 1: motivation

## The problem
Data analysis, statistical research, and teaching have at least one thing in common: these activities all produce many files! As a project unfolds, files evolve with it and often need to be shared with others, for reading or edits.

## The *"poor man's version"* of version control
Many people who don't use Git unwittingly re-invent a poor man's version of it in order to manage the motley collection of files that makeup typical data analytical projects.

mix of files that are the artifacts of a project.

Figure1 depicts a hypothetical analysis of the iris data, captured in a single R source file. With informal version control, contributors create derivative copies of iris.R, decorating the le name with initials, dates, and other descriptors.\
Even when working alone, this leads to multiple versions of iris.R of indeterminate relatedness (Figure 1A). In collaborative settings based on email distribution, the original file swiftly becomes part of a complicated phylogeny that no amount of "Track changes" and good intentions can resolve (Figure 1B). The Git way is to track the evolution of iris.R, through a series of commits, each equipped with an explanatory message. Figure 1C depicts this linear, in situ process, with development and time owing from bottom to top. Figure 1D shows the same history for a common collaborative Git workflow, where contributors work independently but syncregularly to a common version. Especially important versions get a human-readable tag e.g., "draft-01", to signal a meaningful milestone. Yes, there is some pain in adopting theformalism of Git, but it is worth it.

Edit, save, attach. In this workflow, everyone has one (or more!) copies of the document and they circulate via email attachment. Which one is “master”? Is it even possible to say? How do different versions relate to each other? How should versions be reconciled? If you want to see the current best version, how do you get it? All of this usually gets sorted out by social contract and a fairly manual process.

Google Doc. In this workflow, there is only one copy of the document and it lives in the cloud. Anyone can access the most recent version on demand. Anyone can edit or comment or propose a change and this is immediately available to everyone else. Anyone can see who’s been editing the document and, if disaster strikes, can revert to a previous version. A great deal of ambiguity and annoying reconciliation work has been designed away. Managing a project via Git/GitHub is much more like the Google Doc scenario and enjoys many of the same advantages.

## What is `Git`?

## *Now the bad news*
Git was built neither for the "data science" usage, nor forbroad usability. Thankfully, there are plenty of tools that soften Git's sharpest edges, GitHub itself is an example, as is RStudio. In additionto pointing some out, I recommend specific habits and attitudes that reduce frustration.

## What is `GitHub`?
hosting services like GitHub, Bitbucket, and GitLab We have introduced Git’s powerful structure for file management, so where does GitHub fit in? `GitHub` is like DropBox or Google Drive, but more structured, powerful, and programmatic. It allows other people to see your stuff, sync up with you, and perhaps even make changes. The remote host acts as a distribution channel or clearinghouse for your Git-managed project. `GitHub`’s well-designed web interface is a dramatic improvement over traditional Unix Git servers. Github also - offers granular control over who can see, edit, and administer a project. - e.g. easy to create a hyperlink to a specific file or location in a file, at a specific version, which can make conversations about project code or reports much more productive.

We target GitHub – not Bitbucket or GitLab – for the sake of specificity. However, all the big-picture principles and even some mechanics will carry over to these alternative hosting platforms.

One reason for GitHub’s success is that it offers more than a simple source code hosting service [5,6]. It provides developers and researchers with a dynamic and collaborative environment, often referred to as a social coding platform, that supports peer review, commenting, and discussion [7]. A diverse range of efforts, ranging from individual to large bioinformatics projects, laboratory repositories, as well as global collaborations, have found GitHub to be a productive place to share code and ideas and to collaborate

# Part 2: git fundamentals

## basics
There is also a formal notion of an [organization]{.darkblue-bold}, which can be useful for managing repository permissions for entire teams of people.

## Benefits of using hosted version control
Even for private solo projects, it’s a good idea to push your work to a remote location for peace of mind. Why? Because it’s fairly easy to screw up your local Git repository, especially when you’re new at this.

When you are new with Git (or, frankly, even when you are not), it is common to damage the Git infrastructure for a project. Note that your files can be intact and safe, even while the Git tracking is a bit confused. Of course there are official Git remedies, but sometimes the easiest fix is to clone a fresh copy from GitHub, patch things up with the changes that only exist locally, and move on with your life. This workaround obviously requires the existence of a recent copy on GitHub.

The good news is that often only the Git infrastructure is borked up. Your files are just fine! Which makes your Git pickle all the more frustrating. There are official Git solutions to these problems, but they might require expertise and patience you can’t access at 3 a.m. If you’ve recently pushed your work to GitHub, it’s easy to grab a fresh copy, patch things up with the changes that only exist locally, and get on with your life.

The highly functional web interfaces mentioned above are often the most pleasant and natural way to navigate and search your files, even though all the same information exists locally. It is a pleasure to browse through your own work, across multiple projects or files and across time, as if it is a well-designed website. You must push your work to GitHub to enjoy this.

A lone ranger, working on a single computer, can benefit from adopting version control. But not nearly enough to justify the pain of installation and workflow upheaval. There are honestly easier ways to get versioned back ups of files, if that's all you're worried about. But the pros of Git really outweigh the cons when you consider the overhead of working with other people, including your future self.

In a Git-based workflow, you document and, optionally, expose your work as you go. Communication and collaboration are the killer apps of version control.

This has an implication for selecting your first Git projects: It is tempting to pick a quiet, private project. But if you do, you may never find the benefits of formal version control compelling enough to cement the new habit. You will enjoy the most gain for your pain if you pick a project that involves sharing rapidly evolving files with others.

Git really outweigh the cons when you factor in the overhead of communicating and collaborating with other people. Your life is much easier if this is baked into your workflow, as opposed to being a separate process that you dread or neglect.

Exposure: If someone needs to see your work or if you want them to try out your code, they can easily get it from GitHub. If they use Git, they can clone or fork your repository. If they don’t use Git, they can still browse your project on GitHub like a normal website and even grab everything by downloading a zip archive.

Collaboration: If you need to collaborate on data analysis or code development, then everyone should use Git. Use GitHub as your clearinghouse: individuals work independently, then send work back to GitHub for reconciliation and transmission to the rest of the team. The advantage of Git/GitHub is highlighted by comparing these two ways of collaborating on a document:

For new or existing projects, you will:

Dedicate a directory (a.k.a “folder”) to it. Make it an RStudio Project. Make it a Git repository. Go about your usual business. But instead of only saving individual files, periodically you make a commit, which takes a multi-file snapshot of the entire project. Have you ever versioned a file by adding your initials or the date? That is effectively a commit, albeit only for a single file: it is a version that is significant to you and that you might want to inspect or revert to later. Push commits to GitHub periodically. This is like sharing a document with colleagues on DropBox or sending it out as an email attachment. It signals you’re ready to make your work visible to others and invite comment or edits.


# Part 3: configuration

Brace yourself for some pain. The upside is that you can give yourself a pat on the back once you get through this. And you WILL get through this.

## Is R and RStudio up to date?
Concrete example: let’s say the released version of R is 4.7.1, which is totally fictional and well beyond the current version of R at the time of writing. It’s probably OK if you are still on 4.6.whatever, which is one minor version behind and is called “r-oldrel”. Being one minor version behind usually doesn’t cause trouble. Once you are 2 minor versions behind (4.5.whatever or earlier in this example), you will start to suffer. In particular, you can no longer install pre-built binary add-on packages from CRAN.

Is your RStudio “old”? You can expect to update RStudio much more often than R itself. For example, I update RStudio every month or so, whereas I update R 1 or 2 times per year.

# the shell
Many programmers spend lots of time in a shell, as opposed to in GUIs, because it is very fast, concise, and ubiquitous in their relevant computing environments. This is how all work was done before we got the mouse and GUIs.

The most common shell is bash and it gets thrown around as a proxy for “shell” sometimes, just like “Coke” and “Kleenex” are proxies for cola and tissues.

Sometimes we demo the use of a shell for certain tasks, like navigating the file system and doing Git operations, when we don’t want to or can’t use RStudio. Providing shell commands is also less ambiguous and less perishable than describing human interactions with a GUI.
For all these reasons, it is a good idea to learn your way around the shell.

## Opening the shell
Windows is not the ideal platform for scientific computing and software development. A lot of the functionality is going to feel janky and strapped on. Because it is.

## Can you hear me now
We want to establish a two-way communication street (i.e. `pull` and `push`) between two computers..

Unfortunately, we have to front-load a rather fiddly task: decide whether to communicate with `GitHub` via **HTTPS** or **SSH** and setup some credentials accordingly.

These are kind of like passwords, but better.

Another advantage of HTTPS: there are many R packages that call GitHub’s API on your behalf (devtools+usethis, remotes, pak, gh, etc.). Configuring your PAT kills two birds with one stone: this single credential can be used to authenticate to GitHub as a regular Git server and for its REST API. If you authenticate via SSH for “regular” Git work, you will still have to set up a PAT for work that uses the REST API.

## Set up keys for SSH
Create a public-private SSH key pair. Literally, 2 special files, in a special place. Optionally, encrypt the private key with a passphrase (best practice).


# Part4: Workflows 

## Clone your repo to your local computer
You can also personalize this default by setting the `usethis.destdir` option in your `.Rprofile`.

We’re accepting the default behaviour of two other arguments: `rstudio` and `open` (because that’s what most people will want). Take a look at the `RStudio` tab to know what that does.

## Make a local change, commit, and push

Even though GitHub no longer allows username/password authentication, many general Git tools still frame the authentication task with this vocabulary. You shoul provide your PAT as the password, not your web password. Enter your PAT. 

If you already stored your PAT with `gitcreds::gitcreds_set()`, it should be discovered automatically and you will not see a credential challenge.

Working with other people? Before pushing, this will seem counterintuitive, but first let’s stop and `pull` from `GitHub`.
Why? Establish this habit for the future! If you make changes to the repo in the browser or from another machine or (one day) a collaborator has pushed, you will be happier if you pull those changes in before you attempt to push.
When collaborating with other developers) you will usually need to pull changes from the remote (GitHub) before pushing the local changes you have made. For this reason, it’s a good idea to try and get into the habit of pulling before you attempt to push.

## 
Consider if that is appropriate for each file. You can absolutely keep a file locally, without committing it to the Git repo and sending to GitHub. Just let it sit there in your Git pane, without being staged. No harm will be done. If this is a long-term situation, list the file in .gitignore.
If you’re not already in the Git pop-up, click “Commit”
Type a message in “Commit message”, such as “Init project XYZ”.
Click “Commit”